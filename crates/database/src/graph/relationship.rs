use serde::{Deserialize, Serialize};
use strum::{AsRefStr, EnumIter, IntoEnumIterator};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, EnumIter, AsRefStr)]
pub enum RelationshipType {
    // Directory relationships
    #[strum(serialize = "DIR_CONTAINS_DIR")]
    DirContainsDir,
    #[strum(serialize = "DIR_CONTAINS_FILE")]
    DirContainsFile,
    // File relationships
    #[strum(serialize = "FILE_DEFINES")]
    FileDefines,
    #[strum(serialize = "FILE_IMPORTS")]
    FileImports,
    // Definition-imported-symbol relationships
    #[strum(serialize = "DEFINES_IMPORTED_SYMBOL")]
    DefinesImportedSymbol,
    // Definition relationships - Module
    #[strum(serialize = "MODULE_TO_METHOD")]
    ModuleToMethod,
    #[strum(serialize = "MODULE_TO_SINGLETON_METHOD")]
    ModuleToSingletonMethod,
    #[strum(serialize = "MODULE_TO_CLASS")]
    ModuleToClass,
    #[strum(serialize = "MODULE_TO_MODULE")]
    ModuleToModule,
    // Definition relationships - Class
    #[strum(serialize = "CLASS_TO_METHOD")]
    ClassToMethod,
    #[strum(serialize = "CLASS_TO_SINGLETON_METHOD")]
    ClassToSingletonMethod,
    #[strum(serialize = "CLASS_TO_CLASS")]
    ClassToClass,
    #[strum(serialize = "CLASS_TO_LAMBDA")]
    ClassToLambda,
    #[strum(serialize = "CLASS_TO_PROC")]
    ClassToProc,
    #[strum(serialize = "CLASS_TO_INTERFACE")]
    ClassToInterface,
    #[strum(serialize = "CLASS_TO_PROPERTY")]
    ClassToProperty,
    #[strum(serialize = "CLASS_TO_CONSTRUCTOR")]
    ClassToConstructor,
    #[strum(serialize = "CLASS_TO_ENUM_ENTRY")]
    ClassToEnumEntry,
    // Definition relationships - Function
    #[strum(serialize = "FUNCTION_TO_FUNCTION")]
    FunctionToFunction,
    #[strum(serialize = "FUNCTION_TO_CLASS")]
    FunctionToClass,
    #[strum(serialize = "FUNCTION_TO_LAMBDA")]
    FunctionToLambda,
    #[strum(serialize = "FUNCTION_TO_PROC")]
    FunctionToProc,
    // Definition relationships - Lambda
    #[strum(serialize = "LAMBDA_TO_LAMBDA")]
    LambdaToLambda,
    #[strum(serialize = "LAMBDA_TO_CLASS")]
    LambdaToClass,
    #[strum(serialize = "LAMBDA_TO_FUNCTION")]
    LambdaToFunction,
    #[strum(serialize = "LAMBDA_TO_PROC")]
    LambdaToProc,
    #[strum(serialize = "LAMBDA_TO_METHOD")]
    LambdaToMethod,
    #[strum(serialize = "LAMBDA_TO_PROPERTY")]
    LambdaToProperty,
    #[strum(serialize = "LAMBDA_TO_INTERFACE")]
    LambdaToInterface,
    // Definition relationships - Method
    #[strum(serialize = "METHOD_TO_METHOD")]
    MethodToMethod,
    #[strum(serialize = "METHOD_TO_CLASS")]
    MethodToClass,
    #[strum(serialize = "METHOD_TO_FUNCTION")]
    MethodToFunction,
    #[strum(serialize = "METHOD_TO_LAMBDA")]
    MethodToLambda,
    #[strum(serialize = "METHOD_TO_PROC")]
    MethodToProc,
    #[strum(serialize = "METHOD_TO_PROPERTY")]
    MethodToProperty,
    #[strum(serialize = "METHOD_TO_INTERFACE")]
    MethodToInterface,
    // Interface relationships
    #[strum(serialize = "INTERFACE_TO_INTERFACE")]
    InterfaceToInterface,
    #[strum(serialize = "INTERFACE_TO_CLASS")]
    InterfaceToClass,
    #[strum(serialize = "INTERFACE_TO_METHOD")]
    InterfaceToMethod,
    #[strum(serialize = "INTERFACE_TO_FUNCTION")]
    InterfaceToFunction,
    #[strum(serialize = "INTERFACE_TO_PROPERTY")]
    InterfaceToProperty,
    #[strum(serialize = "INTERFACE_TO_LAMBDA")]
    InterfaceToLambda,
    // Reference relationships
    #[strum(serialize = "CALLS")]
    Calls,
    #[strum(serialize = "AMBIGUOUSLY_CALLS")]
    AmbiguouslyCalls,
    #[strum(serialize = "PROPERTY_REFERENCE")]
    PropertyReference,
    // Imported symbol relationships
    #[strum(serialize = "IMPORTED_SYMBOL_TO_IMPORTED_SYMBOL")]
    ImportedSymbolToImportedSymbol,
    #[strum(serialize = "IMPORTED_SYMBOL_TO_DEFINITION")]
    ImportedSymbolToDefinition,
    #[strum(serialize = "IMPORTED_SYMBOL_TO_FILE")]
    ImportedSymbolToFile,
    #[strum(serialize = "EMPTY")]
    Empty,
}

impl RelationshipType {
    pub fn as_str(&self) -> &str {
        // Now this is automatically generated by strum::AsRefStr
        self.as_ref()
    }

    pub fn as_string(&self) -> String {
        self.as_str().to_string()
    }

    pub fn all_types() -> Vec<RelationshipType> {
        RelationshipType::iter().collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_relationship_type_mapping_iteration() {
        // NOTE: The point of this test to validate the behavior of the strum crate/macros
        let mapping = RelationshipType::all_types();
        assert!(!mapping.is_empty());
        let contains_dir_contains_file = mapping.contains(&RelationshipType::DirContainsFile);
        assert!(contains_dir_contains_file);
    }
}
