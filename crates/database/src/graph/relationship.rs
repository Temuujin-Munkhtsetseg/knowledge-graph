use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use strum::{AsRefStr, EnumIter, IntoEnumIterator};

/// Relationship type mappings for efficient storage
#[derive(Debug, Clone, Default)]
pub struct RelationshipTypeMapping {
    /// Map from relationship type enum to integer ID
    type_to_id: HashMap<RelationshipType, u8>,
    /// Map from integer ID to relationship type enum
    id_to_type: HashMap<u8, RelationshipType>,
    /// Next available ID
    next_id: u8,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, EnumIter, AsRefStr)]
pub enum RelationshipType {
    // Directory relationships
    #[strum(serialize = "DIR_CONTAINS_DIR")]
    DirContainsDir,
    #[strum(serialize = "DIR_CONTAINS_FILE")]
    DirContainsFile,
    // File relationships
    #[strum(serialize = "FILE_DEFINES")]
    FileDefines,
    #[strum(serialize = "FILE_IMPORTS")]
    FileImports,
    // Definition-imported-symbol relationships
    #[strum(serialize = "DEFINES_IMPORTED_SYMBOL")]
    DefinesImportedSymbol,
    // Definition relationships - Module
    #[strum(serialize = "MODULE_TO_METHOD")]
    ModuleToMethod,
    #[strum(serialize = "MODULE_TO_SINGLETON_METHOD")]
    ModuleToSingletonMethod,
    #[strum(serialize = "MODULE_TO_CLASS")]
    ModuleToClass,
    #[strum(serialize = "MODULE_TO_MODULE")]
    ModuleToModule,
    // Definition relationships - Class
    #[strum(serialize = "CLASS_TO_METHOD")]
    ClassToMethod,
    #[strum(serialize = "CLASS_TO_SINGLETON_METHOD")]
    ClassToSingletonMethod,
    #[strum(serialize = "CLASS_TO_CLASS")]
    ClassToClass,
    #[strum(serialize = "CLASS_TO_LAMBDA")]
    ClassToLambda,
    #[strum(serialize = "CLASS_TO_PROC")]
    ClassToProc,
    #[strum(serialize = "CLASS_TO_INTERFACE")]
    ClassToInterface,
    #[strum(serialize = "CLASS_TO_PROPERTY")]
    ClassToProperty,
    #[strum(serialize = "CLASS_TO_CONSTRUCTOR")]
    ClassToConstructor,
    #[strum(serialize = "CLASS_TO_ENUM_ENTRY")]
    ClassToEnumEntry,
    // Definition relationships - Function
    #[strum(serialize = "FUNCTION_TO_FUNCTION")]
    FunctionToFunction,
    #[strum(serialize = "FUNCTION_TO_CLASS")]
    FunctionToClass,
    #[strum(serialize = "FUNCTION_TO_LAMBDA")]
    FunctionToLambda,
    #[strum(serialize = "FUNCTION_TO_PROC")]
    FunctionToProc,
    // Definition relationships - Lambda
    #[strum(serialize = "LAMBDA_TO_LAMBDA")]
    LambdaToLambda,
    #[strum(serialize = "LAMBDA_TO_CLASS")]
    LambdaToClass,
    #[strum(serialize = "LAMBDA_TO_FUNCTION")]
    LambdaToFunction,
    #[strum(serialize = "LAMBDA_TO_PROC")]
    LambdaToProc,
    #[strum(serialize = "LAMBDA_TO_METHOD")]
    LambdaToMethod,
    #[strum(serialize = "LAMBDA_TO_PROPERTY")]
    LambdaToProperty,
    #[strum(serialize = "LAMBDA_TO_INTERFACE")]
    LambdaToInterface,
    // Definition relationships - Method
    #[strum(serialize = "METHOD_TO_METHOD")]
    MethodToMethod,
    #[strum(serialize = "METHOD_TO_CLASS")]
    MethodToClass,
    #[strum(serialize = "METHOD_TO_FUNCTION")]
    MethodToFunction,
    #[strum(serialize = "METHOD_TO_LAMBDA")]
    MethodToLambda,
    #[strum(serialize = "METHOD_TO_PROC")]
    MethodToProc,
    #[strum(serialize = "METHOD_TO_PROPERTY")]
    MethodToProperty,
    #[strum(serialize = "METHOD_TO_INTERFACE")]
    MethodToInterface,
    // Interface relationships
    #[strum(serialize = "INTERFACE_TO_INTERFACE")]
    InterfaceToInterface,
    #[strum(serialize = "INTERFACE_TO_CLASS")]
    InterfaceToClass,
    #[strum(serialize = "INTERFACE_TO_METHOD")]
    InterfaceToMethod,
    #[strum(serialize = "INTERFACE_TO_FUNCTION")]
    InterfaceToFunction,
    #[strum(serialize = "INTERFACE_TO_PROPERTY")]
    InterfaceToProperty,
    #[strum(serialize = "INTERFACE_TO_LAMBDA")]
    InterfaceToLambda,
    // Reference relationships
    #[strum(serialize = "CALLS")]
    Calls,
    #[strum(serialize = "AMBIGUOUSLY_CALLS")]
    AmbiguouslyCalls,
    #[strum(serialize = "PROPERTY_REFERENCE")]
    PropertyReference,
}

impl RelationshipType {
    pub fn as_str(&self) -> &str {
        // Now this is automatically generated by strum::AsRefStr
        self.as_ref()
    }

    pub fn all_types() -> Vec<RelationshipType> {
        RelationshipType::iter().collect()
    }
}

impl RelationshipTypeMapping {
    pub fn new() -> Self {
        let mut mapping = Self {
            type_to_id: HashMap::new(),
            id_to_type: HashMap::new(),
            next_id: 1, // Start from 1, reserve 0 for unknown/default
        };

        // Pre-register known relationship types
        mapping.register_known_types();
        mapping
    }

    fn register_known_types(&mut self) {
        for rel_type in RelationshipType::all_types() {
            let id = self.next_id;
            self.type_to_id.insert(rel_type, id);
            self.id_to_type.insert(id, rel_type);
            self.next_id += 1;

            if self.next_id == 0 {
                panic!("Relationship type ID overflow! Consider using UINT16 instead of UINT8");
            }
        }
    }

    pub fn get_type_id(&self, relationship_type: RelationshipType) -> u8 {
        *self.type_to_id.get(&relationship_type).unwrap()
    }

    pub fn get_type_name(&self, type_id: u8) -> &str {
        // Convert enum back to string only when needed
        self.id_to_type.get(&type_id).unwrap().as_str()
    }

    pub fn get_type_enum(&self, type_id: u8) -> RelationshipType {
        *self.id_to_type.get(&type_id).unwrap()
    }

    pub fn get_all_types(&self) -> Vec<RelationshipType> {
        self.id_to_type.values().copied().collect()
    }

    pub fn get_all_mappings(&self) -> HashMap<RelationshipType, u8> {
        self.type_to_id.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_relationship_type_mapping_iteration() {
        let mapping = RelationshipTypeMapping::new();
        for rel_type in mapping.get_all_types() {
            println!("{}", rel_type.as_str());
        }
    }

    #[test]
    fn test_relationship_type_mapping() {
        let mapping = RelationshipTypeMapping::new();
        let type_id = mapping.get_type_id(RelationshipType::DirContainsDir);
        assert_eq!(type_id, 1);
        assert_eq!(mapping.get_type_name(type_id), "DIR_CONTAINS_DIR");
        assert_eq!(
            mapping.get_type_enum(type_id),
            RelationshipType::DirContainsDir
        );
    }
}
